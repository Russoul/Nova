
//From â„•-elim (â„•-induction) we can derive â„•-rec and â„•-unique (â„•-initial):

//Using â„•-pattern-matching lemma
â„•-rec : A â†’ (A â†’ A) â†’ (â„• â†’ A)
â„•-rec z s 0 = z
â„•-rec z s (S t) = s (â„•-rec z s t)

â„•-unique : (f : â„• â†’ A) (f 0 â‰¡ aâ‚€) ((x : â„•) â†’ f (S x) â‰¡ aâ‚ (f x)) â†’ f â‰¡ â„•-rec aâ‚€ aâ‚
â„•-unique f p q = fun-ext (H f p q x)
 where
  H : (f : â„• â†’ A) (f 0 â‰¡ aâ‚€) ((x : â„•) â†’ f (S x) â‰¡ aâ‚ (f x)) (x : â„•) â†’ f x â‰¡ â„•-rec aâ‚€ aâ‚ x
  H f p q 0 = Refl
  H f p q (S x) = Refl

//How do we pack â„•-rec and â„•-unique together to form up â„•-elim?

//We want to define:
A : â„• â†’ ğ•Œ
z : A 0
s : (x : â„•) â†’ A x â†’ A (S x)
---------------------------
â„•-elim A z s : (x : â„•) â†’ A x
â„•-elim A z s 0 = z
â„•-elim A z s (S t) = s t (â„•-elim A z s t)

âˆ
//We can implement:
F : â„• â†’ Î£ A
F = â„•-rec (0, z) ((x, y) â†¦ (S x, s x y))

//F satisfies the following equations:
F 0 = (0, z)
F (S x) = â„•-rec (0, z) ((x, y) â†¦ (S x, s x y)) (S x)
        = (S (F x).Ï€â‚, s (F x).Ï€â‚ (F x).Ï€â‚‚)

//Let's show that
Ï€â‚ âˆ˜ F = id

           âŸ¨const 0, SâŸ©
    ğŸ™ + â„•    - - - - - - > â„•
      |                    |
 id   |                    | id
      |                    |
      v                    v
    ğŸ™ + â„•    - - - - - - > â„•
           âŸ¨const 0, SâŸ©


F âˆ˜ const 0 = const z
F âˆ˜ S = s âˆ˜ F


  const 0        S
ğŸ™ - - - >  â„•  - - - - > â„•
 \         |            |
    \    F |            | F
const z \  v            v
           Î£ A - - - > Î£ A
                 s

                       âŸ¨const 0, SâŸ©
               ğŸ™ + â„•    - - - - - - > â„•
                |                     |
 ğŸ™ + (Ï€â‚ âˆ˜ F)   |                     | Ï€â‚ âˆ˜ F
                |                     |
                v                     v
              ğŸ™ + â„•    - - - - - - >  â„•
                     âŸ¨const 0, SâŸ©

(ğŸ™ + F) : ğŸ™ + â„• â†’ ğŸ™ + Î£ A
(ğŸ™ + Ï€â‚) : ğŸ™ + Î£ A â†’ ğŸ™ + â„•

ğŸ™ + (Ï€â‚ âˆ˜ F) = (ğŸ™ + Ï€â‚) âˆ˜ (ğŸ™ + F)

  Ï€â‚ âˆ˜ F âˆ˜ âŸ¨const 0, SâŸ©
= Ï€â‚ âˆ˜ âŸ¨F âˆ˜ const 0, F âˆ˜ SâŸ©
= Ï€â‚ âˆ˜ âŸ¨const z, s âˆ˜ FâŸ©


  âŸ¨const 0, SâŸ© âˆ˜ (ğŸ™ + (Ï€â‚ âˆ˜ F))
= âŸ¨const 0, S âˆ˜ Ï€â‚ âˆ˜ FâŸ©

(Left ()) â†¦ 0 â†¦ Ï€â‚ (F 0) = Ï€â‚ (0, ...) = 0
(Right x) â†¦ S x â†¦ Ï€â‚ (F (S x)) = Ï€â‚ (S x, s (F x)) = S x

(Left ()) â†¦ (Left ()) â†¦ 0
(Right x) â†¦ (Right (F x).Ï€â‚) = Right (x, ...).Ï€â‚) = Right x â†¦ S x

//Hence we have
â„•-elim : Î  A
â„•-elim = x â†¦ (F x).Ï€â‚‚

//Let's check the equations:
â„•-elim 0 = (F 0).Ï€â‚‚ = z
â„•-elim (S x) = (F (S x)).Ï€â‚‚ = s x (â„•-elim x)


//Can we do something similar with co-data?

//we have

Stream-corec : (X â†’ A) â†’ (X â†’ X) â†’ (X â†’ Stream A)
(Stream-corec h t x).head = h x
(Stream-corec h t x).tail = Stream-corec h t (t x)

Stream-unique : (f : X â†’ Stream) ((f x).head = h x) ((f x).tail = f (t x)) â†’ f â‰¡ Stream-corec f h t

B xs â† xs.head
â‰…
Î± : C â†’ Stream A
f : (xs : Stream A) â¨¯ B xs â†’ C


c : C
-----------
(f (xs, t) = c) â‡’ xs = Î± c

x : X
---------
f : A x â†’ B x


(x : A) âŠ¦ B type
----------------
B â† (x : A) type

f : B â† (a/x : A)
aâ‚€ : A
b : B[aâ‚€/x]
---------------
f b : A

f : B â† (a/x : A)
b : B[a/x]
-----------------
f b = a : A


h : B xs â† xs.head
t : B xs â† xs.tail
------------------
Stream-coind : Î£ B â†’ Stream A
(f t).Ï€â‚ =


(xs : Stream A) â¨¯ B xs â†’ (x : A) â¨¯ (xs : Stream A) â¨¯ B (x :: xs)

h : (
h : (x : A) â¨¯ (xs : B x) â¨¯ B (
----------------------------------
Stream-coind : (xs : Stream A) â¨¯ B

