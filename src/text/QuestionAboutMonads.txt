Given:
StateT : Type â†’ Monad â†’ (Type â†’ Type)
StateT s m a = s â†’ m (s, a)

pure : a â†’ StateT s m a
pure x s = pure (s, x)

//Bind via join for arbitrary monad
(>>=) : m a â†’ (a â†’ m b) â†’ m b
(t >>= g) = join (m g t)

join : StateT s m (StateT s m a) â†’ StateT s m a
join F s = do
 (s, G) â† F s
 G s

 F s >>= (s, G) â†¦ G s >>= (s, x) â†¦ pure (s, x)
 =
 join (m ((s, G) â†¦ G s >>= (s, x) â†¦ pure (s, x)) (F s))
 =
 join (m ((s, G) â†¦ join (m ((s, x) â†¦ pure (s, x)) (G s))) (F s))

StateT s m Î± : StateT s m a â†’ StateT s m b
StateT s m Î± F x = do
  (s, r) â† F x
  pure (s, Î± r)

State : Type â†’ (Type â†’ Type)
State s a = s â†’ (s, a)

We want to show:
âˆ€s. âˆ€a. (State s a â‰… (m : Monad) â†’ StateT s m a)

Category of Monads.
Objects are monads
Arrows are functions f : âˆ€a. M a â†’ N a
a    M a        N a


b    M b        N b

that make the square commute (natural transformation)

that additionally preserve monad structure:
(x : a) âŠ¦ f (pure x) = pure x : N a
(t : MÂ² a) âŠ¦ f (join t) = join (f (m f t) : NÂ² a) : MÂ² a â†’ NÂ² a
(Î± : a â†’ b) (t : M a) âŠ¦ f (M Î± t) = N Î± (f t) : N b

////////
M (f @ a) : MÂ² a â†’ M (N a)

f @ N a : M (N a) â†’ NÂ² a

M (f @ a) ; f @ N a : MÂ² a â†’ NÂ² a
///////

Checking the identity law:
Given a monad M, we need to provide an arrow:
f : âˆ€a. M a â†’ M a
such that
f (pure x) = pure x
f (join t) = join ((f @ N a) (m (f @ a) t))
f (M Î± t) = M Î± (f t)

take f â‰” id
then:
id (pure x) = pure x âœ”
id (join t) = join t âœ”
id (M Î± t) = M Î± (id t) = M Î± t âœ”

Checking composition law:
Given monads M N O, and arrows
f : âˆ€a. M a â†’ N a
g : âˆ€a. N a â†’ O a
we have to provide a composite arrow, that is a function:
h : âˆ€a. M a â†’ O a
such that
h (pure x) = pure x
h (join t) = join (h (M h t))
h (M Î± t) = O Î± (h t)

take h â‰” g âˆ˜ f, hence
we have to show:
*) g (f (pure x)) = pure x
   //f is an arrow hence f (pure x) = pure x
   g (pure x) = pure x
   // g is an arrow hence g (pure x) = pure x
   pure x = pure x âœ”
*) g (f (join t)) = join ((g âˆ˜ f) (M (g âˆ˜ f) t))
   //f is an arrow hence f (join t) = join (f (M f t))
   g (join (f (m f t))) = join ((g âˆ˜ f) (M (g âˆ˜ f) t))
   //g is an arrow hence âˆ€t. g (join t) = join (g (N g t))
   //take t â‰” f (m f t)
   //hence
   //g (join (f (m f t))) = join (g (N g (f (M f t))))
   join (g (N g (f (M f t)))) = join ((g âˆ˜ f) (m (g âˆ˜ f) t))
   //it's enough to show:
   g (N g (f (M f t))) = (g âˆ˜ f) (M (g âˆ˜ f) t)
   //m is a functor hence M (g âˆ˜ f) = M g âˆ˜ M f
   g (N g (f (M f t))) = (g âˆ˜ f) ((M g âˆ˜ M f) t)
   //By definition of function composition:
   g (N g (f (M f t))) = g (f (N g (M f t)))
   //It's enough to show:
   N g (f (M f t)) = f (M g (M f t))
   //
   N g (f (M f t)) = f (M (g âˆ˜ f) t)
   //f preserves map
   N g (f (M f t)) = N (g âˆ˜ f) (f t)
   //f preserves map
   N g (N f (f t)) = N (g âˆ˜ f) (f t)
   //functor composition law
   N (g âˆ˜ f) (f t) = N (g âˆ˜ f) (f t) âœ”
*) (g âˆ˜ f) (M Î± x) = O Î± ((g âˆ˜ f) x)
   //f preserves map
   g (N Î± (f x)) = O Î± ((g âˆ˜ f) x)
   //g preserves map
   O Î± (g (f x)) = O Î± ((g âˆ˜ f) x) âœ”

Last we need to show that composition is associative:
Given four monads:
M N O P
arrows:
f : M â‡ N
g : N â‡ O
h : O â‡ P
we need to show that:
h âˆ˜ (g âˆ˜ f) = (h âˆ˜ g) âˆ˜ f : M â‡ P
It's enough to show that
composition of underlying functions is associative:
h âˆ˜ (g âˆ˜ f) = (h âˆ˜ g) âˆ˜ f : M a â†’ P a
But we know that function composition is associative.

(do x <- p; q)
=
p >>= (x â†¦ q)
=
join (m (x â†¦ q) p)

//Let's see how monad morphism acts on a do-block:
f (m.do x â† p; q)
=
f (join (m (x â†¦ q) p))
=
join (f (m f (m (x â†¦ q) p)))
=
join (f (m (f âˆ˜ (x â†¦ q)) p))
=
join (n (f âˆ˜ (x â†¦ q)) (f p))
=
(n.do x â† f p; f q)

We need to show that in the category of monads
StateT s : Monad â†’ Monad
is an endofunctor
We know that action of StateT on monads (by definition)
We need to define its action on monad morphisms:
Given monads M N
and monad morphism  f : M â‡ N
we need to define:
StateT s f : StateT s M â‡ StateT s N
that is we need
F : âˆ€a. StateT s M a â†’ StateT s N a
such that
F (pure x) = pure x
F (join t) = join (F (m F t))
F (StateT s M Î± x) = StateT s N Î± (F x)

//In other words we need to provide:
F : âˆ€a. (s â†’ M (s, a)) â†’ (s â†’ N (s, a))
F Î³ x = f (Î³ x)
//now let's see if the equations hold:

*) F (pure x) = pure x : StateT s M a
   //By definition of F
   (s â†¦ f (pure x s)) = pure x
   //By definition of pure
   (s â†¦ f (pure x s)) = (s â†¦ pure (s, x))
   //it's enough to show:
   f (pure x s) = pure (s, x)
   //f preserves pure
   pure x s = pure (s, x)
   //by defition of pure at StateT
   pure (s, x) = pure (s, x) âœ”
*) F (join t) = join (F (StateT s M F t))
   //By definition of F
   (x â†¦ f (join t x)) = join (x â†¦ f (StateT s M F t x))
   //It's enough to show
   f (join t x) = join (x â†¦ f (StateT s M F t x)) x
   //By definition of join at StateT:
   f (do (x, G) â† t x; G x) = do (x, G) â† f (StateT s M F t x); G x
   //f preserves do
   do (x, G) â† f (t x); f (G x) = do (x, G) â† f (do (x, r) â† t x; pure (x, F r)); G x
   //f preserves do
   do (x, G) â† f (t x); f (G x) = do (x, G) â† (do (x, r) â† f (t x); f (pure (x, F r))); G x
   //do is associative
   do (x, G) â† f (t x); f (G x) = do (x, r) â† f (t x); (x, G) â† f (pure (x, F r)); G x
   //rename
   do (x, r) â† f (t x); f (r x) = do (x, r) â† f (t x); (x, G) â† f (pure (x, F r)); G x
   //It's enough to show:
   f (r x) = do (x, G) â† f (pure (x, F r)); G x
   //f preserves pure
   f (r x) = do (x, G) â† pure (x, F r); G x
   //do of pure
   f (r x) = F r x
   //By definition of F
   f (r x) = f (r x) âœ”
*) F (StateT s M Î± r) = StateT s N Î± (F r)
   //it's enough to show
   F (StateT s M Î± r) x = StateT s N Î± (F r) x
   //By definition of F
   f (StateT s M Î± r x) = StateT s N Î± (F r) x
   // By definition of StateT map
   f (do (x, o) â† r x; pure (x, Î± o)) = do (x, o) â† F r x; pure (x, Î± o)
   //By definition of F
   f (do (x, o) â† r x; pure (x, Î± o)) = do (x, o) â† f (r x); pure (x, Î± o)
   //f preserves do
   (do (x, o) â† f (r x); f (pure (x, Î± o))) = do (x, o) â† f (r x); pure (x, Î± o)
   //f of pure
   (do (x, o) â† f (r x); pure (x, Î± o)) = do (x, o) â† f (r x); pure (x, Î± o) âœ”

//Hence we've defined the morphism action of the StateT endofunctor.
//We need to show that it preserves functor laws:

//First we need to show that it preserves identity:
Given monad M
F id(M) = id(StateT s M) : âˆ€a. StateT s M a â†’ StateT s M a
//By definition of F:
(Î³ x â†¦ Î³ x) = id(StateT s M) : âˆ€a. StateT s M a â†’ StateT s M a
//We have identity function on the left
id = id(StateT s M) : âˆ€a. StateT s M a â†’ StateT s M a
//We have identity function on the right by definition of identity morphism
id = id : âˆ€a. StateT s M a â†’ StateT s M a âœ”

//Next we show that it preserves composition:
Given monads M N O
monad morphisms: f : M â‡ N
                 g : N â‡ O


F (g âˆ˜ f) = F g âˆ˜ F f : StateT s M a â†’ StateT s O a
//By definition of F
(Î³ x â†¦ (g âˆ˜ f) (Î³ x)) = (Î³ x â†¦ g (Î³ x)) âˆ˜ (Î³ x â†¦ f (Î³ x)) : StateT s M a â†’ StateT s O a
//It's enough to show:
g (f (Î³ x)) = g (f (Î³ x)) âœ”
//Hence StateT is an endofunctor in the category of monads.

//Our original goal is to show:
âˆ€s. âˆ€a. (State s a â‰… (m : Monad) â†’ StateT s m a)
//Note that State s a = StateT s id a
//hence
âˆ€s. âˆ€a. (StateT s id a â‰… (m : Monad) â†’ StateT s m a)

//First let's show that the identity monad is the initial object in the
//category of monads
Id : Type â†’ Type
Id a = a

pure : a â†’ Id a
pure = id

join : Id (Id a) â†’ Id a
join = id

//Hence for arbitrary monad M we need to provide a monad arrow
! : Id â‡ M
which must be unique

In other words we need to provide:
! : Id a â†’ M a
! = pure

! (pure x) = pure x
! x = pure x
pure x = pure x âœ”

! (join x) = join (! (Id ! x))
! x = ! (Id ! x)
! x = ! (! x)
! x = ! (pure x)
pure x = pure x âœ”

! (Id f x) = M f (! x)
! (f x) = M f (pure x)
pure (f x) = pure (f x) âœ”

//moreover for any arrow
? : âˆ€a. Id a â†’ M a
//we need to show:
! = ?
//it's enough to show that:
! x = ? x
pure x = ? x //This has to be proven by parametricity somehow.

//We want to apply the Yoneda lemma for StateT endofunctor.
//For that we'll define a set-valued functor:
a âŠ¦ Ï„ m = StateT s m a

//Yoneda lemma:
a âŠ¦ Ï„ X â‰… Nat(Hom(X, _), Ï„)
//take X â‰” Id : Monad
a âŠ¦ Ï„ Id â‰… Nat(Hom(Id, _), Ï„)
//Note that for any X: Hom(Id, X) â‰… ğŸ™, for Id is the initial object
//Hence Hom(Id, _) = const ğŸ™ //Constant functor
                   //Need parametricity here
a âŠ¦ Ï„ Id â‰… Nat(const ğŸ™, Ï„) â‰… (âˆ€m. Ï„ m)
a âŠ¦ State s a â‰… Nat(const ğŸ™, Ï„) â‰… (âˆ€m. Ï„ m)
//
a âŠ¦ State s a â‰… (âˆ€m. StateT s m a)
//
âˆ€a. State s a â‰… (âˆ€m. StateT s m a)

--------------------------------------------------------


//Fix the category of types and functions â€” Type

//Functor is an endofunctor on Type

//Given a functor F and a type a
//we write
F a : ğ•Œ
//to represent the functorial action of F on object a.

//Given a functor F and a function f : a â†’ b
//we write
F f : F a â†’ F b
//to represent the functorial action of F on morhism f.

//Notation:
Mâ° a = a
MÂ¹âºâ¿ a = M (Mâ¿ a)

//Monad is a Functor M with additional two functions:
pure : âˆ€a. a â†’ M a
join : âˆ€a. MÂ² a â†’ M a
//which satisfy the following laws:
(x : a) âŠ¦ M f (pure x) = pure (f x)            } naturality laws
(t : MÂ² a) âŠ¦ M f (join t) = join (MÂ² f t)      }

(t : M a) âŠ¦ join (pure t) = t                  }
(t : M a) âŠ¦ join (M pure t) = t                } monoid laws
(t : MÂ³ a) âŠ¦ join (M join t) = join (join t)   }

//Define a category of Monads:
//Objects are monads
//Arrows are functions f : âˆ€a. M a â†’ N a
//that additionally have the following properties:
(x : a) âŠ¦ f (pure x) = pure x : N a
(t : MÂ² a) âŠ¦ f (join t) = join (f (M f t) : NÂ² a) : N a
(Î± : a â†’ b) (t : M a) âŠ¦ f (M Î± t) = N Î± (f t) : N b

//Isomorphism between types A and B is a pair of both-way functions between A and B that compose to identity in both ways.

//The goal is to prove:
(âˆ€(M : Monad). âˆ€a. a â†’ M a) â‰… ğŸ™
//In english: the space of functions that for arbitrary monad M, arbitrary type a take an element of a to an element of M a is
//isomorphic to one element space (ğŸ™).

//PROOF:

//Define a quotient inductive type:
data FreeMonad : ğ•Œ â†’ ğ•Œ where
  Map : (a â†’ b) â†’ FreeMonad a â†’ FreeMonad b
  Pure : a â†’ FreeMonad a
  Join : FreeMonadÂ² a â†’ FreeMonad a
  //Define Bind
  Bind : FreeMonad a â†’ (a â†’ FreeMonad b) â†’ FreeMonad b
  Bind t f = Join (Map f t)

  //Functor laws
  (t : FreeMonad a) âŠ¦ Map id t = t : FreeMonad a
  (t : FreeMonad a) âŠ¦ Map (g âˆ˜ f) t = Map g (Map f t) : FreeMonad a

  //Define
  MapÂ² f = Map (Map f)

  //naturality laws
  Map f (Pure x) = Pure (f x) : FreeMonad a
  (t : FreeMonadÂ² a) âŠ¦ Map f (Join t) = Join (MapÂ² f t) : FreeMonad a

  //Monoid laws
  (t : FreeMonad a) âŠ¦ Join (Pure t) = t : FreeMonad a
  (t : FreeMonad a) âŠ¦ Join (Map Pure t) = t : FreeMonad a
  (t : FreeMonadÂ³ a) âŠ¦ Join (Map Join t) = Join (Join t) : FreeMonad a


//Let's prove that
(t : FreeMonad a) âŠ¦ Bind t Pure = t : FreeMonad a
                    Join (Map Pure t) = t âœ”

//Let's prove that
(x : a) âŠ¦ Bind (Pure x) f = f x : FreeMonad b
          Join (Map f (Pure x)) = f x
          Join (Pure (f x)) = f x
          f x = f x âœ”

//Let's prove that
(t : FreeMonad a) âŠ¦ (do y â† (do x â† t; f); g) = (do x â† t; y â† f; g) : FreeMonad a
                    Join (Map (y â†¦ g) (do x â† t; f)) = Join (Map (x â†¦ do y â† f; g) t)
                    Join (Map (y â†¦ g) (Join (Map (x â†¦ f) t))) = Join (Map (x â†¦ Join (Map (y â†¦ g) f)) t)
                    Join (Map (y â†¦ g) (Join (Map (x â†¦ f) t))) = Join (Map (Join . (x â†¦ Map (y â†¦ g) f)) t)
                    Join (Map (y â†¦ g) (Join (Map (x â†¦ f) t))) = Join (Map Join (Map (x â†¦ Map (y â†¦ g) f) t))
                    Join (Map (y â†¦ g) (Join (Map (x â†¦ f) t))) = Join (Join (Map (x â†¦ Map (y â†¦ g) f) t))
                    Join (Join (MapÂ² (y â†¦ g) (Map (x â†¦ f) t))) = Join (Join (Map (x â†¦ Map (y â†¦ g) f) t))
                    MapÂ² (y â†¦ g) (Map (x â†¦ f) t) = Map (Map (y â†¦ g) . (x â†¦ f)) t
                    MapÂ² (y â†¦ g) (Map (x â†¦ f) t) = Map (Map (y â†¦ g)) (Map (x â†¦ f) t)
                    MapÂ² (y â†¦ g) (Map (x â†¦ f) t) = MapÂ² (y â†¦ g) (Map (x â†¦ f) t) âœ”


//FreeMonad satisfies functor laws and monad laws.

//define
interp : âˆ€(M : Monad). FreeMonad a â†’ M a
interp M (Pure x) = pure x
interp M (Map f t) = M f (interp M t)
interp M (Join t) = join (M (interp M) (interp M t))

interp M (Map id t) = interp M t
M id (interp M t) = interp M t
interp M t = interp M t âœ”

interp M (Map (g âˆ˜ f) t) = interp M (Map g (Map f t))
M (g âˆ˜ f) (interp M t) = interp M (Map g (Map f t))
M (g âˆ˜ f) (interp M t) = M g (interp M (Map f t))
M (g âˆ˜ f) (interp M t) = M g (M f (interp M t))
M g (M f (interp M t)) = M g (M f (interp M t)) âœ”

interp M (Map f (Pure x)) = interp M (Pure (f x))
M f (interp M (Pure x)) = pure (f x)
M f (pure x) = pure (f x)
pure (f x) = pure (f x) âœ”

interp M (Map f (Join t)) = interp M (Join (MapÂ² f t))
M f (join (M (interp M) (interp M t))) = join (M (interp M) (interp M (MapÂ² f t)))
join (MÂ² f (M (interp M) (interp M t))) = join (M (interp M) (interp M (MapÂ² f t)))
MÂ² f (M (interp M) (interp M t)) = M (interp M) (interp M (MapÂ² f t))
MÂ² f (M (interp M) (interp M t)) = M (interp M) (interp M (Map (Map f) t))
MÂ² f (M (interp M) (interp M t)) = M (interp M) (M (Map f) (interp M t))
MÂ² f (M (interp M) (interp M t)) = M (interp M . Map f) (interp M t)
MÂ² f (M (interp M) (interp M t)) = M (M f . interp M) (interp M t)
MÂ² f (M (interp M) (interp M t)) = M (M f) (M (interp M) (interp M t))
MÂ² f (M (interp M) (interp M t)) = MÂ² f (M (interp M) (interp M t)) âœ”

(t : FreeMonad a) âŠ¦ interp (Join (Pure t)) = interp M t : M a
                    join (M (interp M) (interp M (Pure t))) = interp M t
                    join (M (interp M) (pure t)) = interp M t
                    join (pure (interp M t)) = interp M t
                    interp M t = interp M t âœ”

(t : FreeMonad a) âŠ¦ interp M (Join (Map Pure t)) = interp M t : M a
                    join (M (interp M) (interp M (Map Pure t))) = interp M t
                    join (M (interp M) (M Pure (interp M t))) = interp M t
                    join (M (interp M . Pure) (interp M t)) = interp M t
                    join (M pure (interp M t)) = interp M t
                    interp M t = interp M t âœ”

(t : FreeMonadÂ³ a) âŠ¦ interp (Join (Map Join t)) = interp (Join (Join t)) : M a
                     join (M (interp M) (interp M (Map Join t))) = join (M (interp M) (interp M (Join t)))
                     join (M (interp M) (M Join (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (M (interp M . Join) (interp M t)) = join (M (interp M) (interp M (Join t)))
                     join (M (join . M (interp M) . interp M) (interp M t)) = join (M (interp M) (interp M (Join t)))
                     join (M join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (interp M (Join t)))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (M (interp M) (join (M (interp M) (interp M t))))
                     join (join (M (M (interp M) . interp M) (interp M t))) = join (join (MÂ² (interp M) (M (interp M) (interp M t))))
                     M (M (interp M) . interp M) (interp M t) = MÂ² (interp M) (M (interp M) (interp M t))
                     M (M (interp M) . interp M) (interp M t) = M (M (interp M)) (M (interp M) (interp M t))
                     M (M (interp M)) (M (interp M) (interp M t)) = M (M (interp M)) (M (interp M) (interp M t)) âœ”


//Note that interp is automatically a natural transformation (preserves map) and
//a monad morphism (moreover preserves pure and join).

//Let's show that interp is a unique monad morphism
(M : Monad) (Î¼ : FreeMonad â‡ M) âŠ¦ Î¼ = interp M : âˆ€a. FreeMonad a â†’ M a
//By function extensionality
(M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonad a) âŠ¦ Î¼ t = interp M t : M a
//By induction on t
* (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (x : a) âŠ¦ Î¼ (Pure x) = interp M (Pure x)
  //by definition of interp
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (x : a) âŠ¦ Î¼ (Pure x) = pure x
  //by properties of a monad morphism
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (x : a) âŠ¦ pure x = pure x âœ”

* (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonad a) (f : a â†’ b) âŠ¦ Î¼ (Map f t) = interp M (Map f t) : M b
  //By definition of interp
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonad a) (f : a â†’ b) âŠ¦ Î¼ (Map f t) = Map f (interp M t)
  //By properties of a monad morphism
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonad a) (f : a â†’ b) âŠ¦ M f (Î¼ t) = M f (interp M t)
  //congruence
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonad a) (f : a â†’ b) âŠ¦ Î¼ t = interp M t
  //By induction hypothesis
  âœ”

* (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonadÂ² a) âŠ¦ Î¼ (Join t) = interp M (Join t) : M b
  //By definition of interp
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonadÂ² a) âŠ¦ Î¼ (Join t) = join (M (interp M) (interp M t))
  //By properties of a monad morphism
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonadÂ² a) âŠ¦ join (M Î¼ (Î¼ t)) = join (M (interp M) (interp M t))
  //congruence
  (M : Monad) (Î¼ : FreeMonad â‡ M) (a : ğ•Œ) (t : FreeMonadÂ² a) âŠ¦ M Î¼ (Î¼ t) = M (interp M) (interp M t)
  //By induction hypothesis
  âœ”

//Hence FreeMonad is the initial object in the category of monads.

//Let's show that FreeMonad and Id are isomorphic objects of the category of monads.

//There is a monad morphism:
pure : âˆ€a. Id a â†’ FreeMonad a

//interp gives us a morphism in other direction:
interp Id : âˆ€a. FreeMonad a â†’ Id a

interp Id . pure = pure = id //follows immediately from definition of interp

pure . interp Id = id
//By function extensionality
(t : FreeMonad a) âŠ¦ pure (interp Id t) = t
//By induction on t
* (x : a) âŠ¦ pure (interp Id (Pure x)) = Pure x
            pure (pure x) = Pure x
            pure (id x) = Pure x
            pure x = Pure x
            Pure x = Pure x âœ”
* (t : FreeMonad a) (f : a â†’ b) âŠ¦ pure (interp Id (Map f t)) = Map f t
                                  pure (Id f (interp Id t)) = Map f t
                                  //pure is a natural transformation
                                  Map f (pure (interp Id t)) = Map f t
                                  //By induction hypothesis
                                  Map f t = Map f t âœ”
* (t : FreeMonadÂ² a) âŠ¦ Pure (interp Id (Join t)) = Join t
                       Pure (join (Id (interp Id) (interp Id t))) = Join t
                       //pure preserves join
                       Join (pure (Id pure (Id (interp Id) (interp Id t)))) = Join t
                       Join (pure (Id pure (interp Id (interp Id t)))) = Join t
                       Join (interp Id (interp Id t)) = Join t
                       Join (interp Id t) = Join t
                       Join t = Join t âœ”

//Hence Id and FreeMonad are isomorphic objects of the monad category.

âˆ€M. ((âˆ€a. a â†’ M a) â‰… ğŸ™)
â‰…
âˆ€M. ((âˆ€a. Id a â†’ M a) â‰… ğŸ™)
â‰…
âˆ€M. ((âˆ€a. FreeMonad a â†’ M a) â‰… ğŸ™)
//I am stuck
//We know that the set of monad morphisms (Free â‡ M) is isomorphic to singleton set but we can't say the same about
//merely functions (âˆ€a. FreeMonad a â†’ M a)
