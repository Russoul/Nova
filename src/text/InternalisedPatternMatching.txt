//Lemma useful for internalised pattern-matching

(x : A) âŠ¦ P type
((x : A) â¨¯ P) â‰… ğŸ™
aâ‚€ : A
aâ‚ : A
pâ‚€ : P(aâ‚€)
------------------
(aâ‚€ â‰¡ aâ‚) â‰… P(aâ‚)

âˆ
=>) Assume e : aâ‚€ â‰¡ aâ‚
    By equality reflection we have aâ‚€ = aâ‚
    hence pâ‚€ : P(aâ‚)
<=) The sigma type is equivalent to ğŸ™ hence
    hence any two elements of it are equal
    hence we have:
    (aâ‚€, pâ‚€) â‰¡ (aâ‚, pâ‚)
    But via pair-extensionality we have
    aâ‚€ â‰¡ aâ‚
><) any two elements of aâ‚€ â‰¡ aâ‚ are equal due to UIP
<>) pâ‚ : P(aâ‚)
    pâ‚€ : P(aâ‚)
    we need to show that (pâ‚ â‰¡ pâ‚€)
    Due to the equivalence we have:
    (aâ‚€, pâ‚€) â‰¡ (aâ‚, pâ‚)
    Via pair-extensionality we have
    pâ‚€ = pâ‚ âˆ

//Justification of pattern-matching on two â„•

(x y : â„•) âŠ¦ A type

aâ‚€â‚€ : A(Z/x, Z/y)
aâ‚€â‚ : (y : â„•) â†’ A(Z/x) â†’ A(Z/x, S y/ y)
(x : â„•) (h : (y : â„•) â†’ A) âŠ¦ aâ‚â‚€ : A (S x / x, 0 / y)
(x : â„•) (h : (y : â„•) â†’ A) âŠ¦ aâ‚â‚€ : (y : â„•) â†’ A (S x / x) â†’ A (S x / x, S y / y)

aâ‚€ : (y : â„•) â†’ A(Z/x)                    }
aâ‚€ Z = aâ‚€â‚€                               } â‰… ğŸ™
(y : â„•) â†’ aâ‚€ (S y) = aâ‚€â‚ y (aâ‚€ y)        }

(x : â„•) (h : (y : â„•) â†’ A) âŠ¦
   aâ‚ : (y : â„•) â†’ A (S x / x)      }
   aâ‚ Z = aâ‚â‚€                      } â‰… ğŸ™
   aâ‚ (S y) = aâ‚â‚€ y (aâ‚ y)         }

//Pick x â‰” x, h â‰” f x

   aâ‚ : (y : â„•) â†’ A (S x / x)                 }
   aâ‚ Z = aâ‚â‚€(f x / h)                        } â‰… ğŸ™
   (y : â„•) â†’ aâ‚ (S y) = aâ‚â‚€(f x / h) y (aâ‚ y) }

f : (x y : â„•) â†’ A                    }
f Z â‰¡ aâ‚€                             } â‰… ğŸ™
(x : â„•) â†’ f (S x) â‰¡ aâ‚ (f x / h)     }

f Z y â‰¡ aâ‚€
â‰…
f Z Z = aâ‚€â‚€
(y : â„•) â†’ f Z (S y) = aâ‚€â‚ y (f Z y)

(x : â„•) â†’ f (S x) â‰¡ aâ‚ (f x / h)
â‰…
(x : â„•) â†’ f (S x) Z = aâ‚â‚€(f x / h)
          â¨¯
          f (S x) (S y) = aâ‚â‚€(f x / h) y (f (S x) y)

And hence we have:


f : (x y : â„•) â†’ A                                       }
f Z Z = aâ‚€â‚€                                             }
(y : â„•) â†’ f Z (S y) = aâ‚€â‚ y (f Z y)                     } â‰… ğŸ™
(x : â„•) â†’ f (S x) Z = aâ‚â‚€(f x / h)                      }
(x y : â„•) â†’ f (S x) (S y) = aâ‚â‚€(f x / h) y (f (S x) y)  }






//Let's show that the head equation defines a unique function
head : Vect (S n) A â†’ A
head (x :: xs) = x


?aâ‚€ : (n : â„•) â†’ (0 â‰¡ S n) â†’ A
?aâ‚ : (z : â„•) â†’ A â†’ Vect z A â†’ (h : (n : â„•) â†’ (z â‰¡ S n) â†’ A) â†’ (n : â„•) â†’ (S z â‰¡ S n) â†’ A
----------------------------------------------------------------------------------------
head : (z : â„•) â†’ Vect z A â†’ (n : â„•) â†’ (z â‰¡ S n) â†’ A  }
head 0 [] = ?aâ‚€                                      } â‰… ğŸ™
head (S z) (x :: xs) = ?aâ‚ z x xs (head z xs)        }

Pick ?aâ‚€ n contra â‰” absurd contra
     ?â‚ z x xs h = x

Hence we have:

head : (z : â„•) â†’ Vect z A â†’ (n : â„•) â†’ (z â‰¡ S n) â†’ A  }
head 0 [] = n contra â†¦ absurd contra                 } â‰… ğŸ™
head (S z) (x :: xs) = n _ â†¦ x                       }

//Note that:
 (n : â„•) â†’ (0 â‰¡ S n) â†’ A
 â‰…
 (n : â„•) â†’ ğŸ˜ â†’ A
 â‰…
 ğŸ™

//Hence
(head 0 [] = n contra â†¦ absurd contra) â‰… ğŸ™

//Hence we have:

ğŸ™

â‰…

head : (z : â„•) â†’ Vect z A â†’ (n : â„•) â†’ (z â‰¡ S n) â†’ A
head (S z) (x :: xs) = n _ â†¦ x

â‰…

head : (n z : â„•) â†’ (z â‰¡ S n) â†’ Vect z A â†’ A
head n (S z) prf (x :: xs) = x

â‰…

head : (n : â„•) â†’ Vect (S n) A â†’ A
head (S n) (x :: xs) = x





//Defines a unique function
f : (aâ‚€ aâ‚ : A) (a : aâ‚€ â‰¡ aâ‚) â†’ B } â‰… ğŸ™
f x x Refl â‰¡ ?p âˆˆ B(x, x, Refl)  }

âˆ
=>) Trivial
<=) f aâ‚€ aâ‚ a = J A aâ‚€ (aâ‚.a. B) ?p(aâ‚€/x) aâ‚ a
    f x x Refl = J A x (aâ‚.a. B) ?p(aâ‚€/x) x Refl = ?p(aâ‚€/x) //By Î²-rule
<>) trivial
><) we have:
    f : (aâ‚€ aâ‚ : A) (a : aâ‚€ â‰¡ aâ‚) â†’ B
    e : f x x Refl â‰¡ ?p âˆˆ B(x, x, Refl)

    we need to show that

    (f, e) = (aâ‚€ aâ‚ a â†¦ J A aâ‚€ (aâ‚.a. B) ?p(aâ‚€/x) aâ‚ a, _)

    It's enough to show that

    f aâ‚€ aâ‚ a = J A aâ‚€ (aâ‚.a. B) ?p(aâ‚€/x) aâ‚ a

    Which is equivalent to

    f aâ‚€ aâ‚ a = J A aâ‚€ (aâ‚.a. B) (f aâ‚€ aâ‚€ Refl) aâ‚ a

    Which is true by the Î·-rule. âˆ











  StreamF(X) = A * X



              (h, t)
     X  - - - - - - - > A â¨¯ X
     |                     |
     |                     |
  ğœˆ  |                     | A â¨¯ ğœˆ
     |                     |
     |                     |
     v                     v
    Stream A - - - - -> A â¨¯ Stream A
           (head, tail)


//Existence
(x : X) âŠ¦ (A â¨¯ ğœˆ) ((h, t) x) â‰¡ (head, tail) (ğœˆ x) âˆˆ A â¨¯ Stream A
â‰…
(x : X) âŠ¦ (h x, ğœˆ (t x)) â‰¡ (head (ğœˆ x), tail (ğœˆ x)) âˆˆ A â¨¯ Stream A
â‰…
(x : X) âŠ¦ h x â‰¡ head (ğœˆ x) âˆˆ A
(x : X) âŠ¦ ğœˆ (t x) â‰¡ tail (ğœˆ x) âˆˆ Stream A

//Initiality
Given arbitrary
f : X â†’ Stream A
such that the diagram commutes (replacing ğœˆ with f)
ğœˆ â‰¡ f âˆˆ X â†’ Stream A

//Pattern-matching:
?t : X â†’ A
?h : X â†’ X
-------------------------------
f : X â†’ Stream A         }
(f x).head â‰¡ ?t          } â‰… ğŸ™
(f x).tail â‰¡ f (?h x)    }


example:

zip : Stream A â¨¯ Stream B â†’ Stream (A â¨¯ B)
(zip (xs, ys)).head = (xs.head, ys.head)
(zip (xs, ys)).tail = zip (xs.tail, ys.tail)

//Case-splitting on â„•

f : â„• â†’ â„•        }
f 0 = ?â‚€         } â‰… ğŸ™
f (S x) = ?â‚ x   }

âˆ Special case of the general pattern-matching lemma, where ?â‚ doesn't depend on the induction hypothesis âˆ




//Nested â„•-case justification

f : (x : â„•) â†’ A x   }
f 0 = ?â‚€            }
f 1 = ?â‚            } â‰… ğŸ™
f (2 + x) = ?â‚‚ x    }

âˆ

// By case-splitting lemma we have:

?â‚€ : A 0
?â‚ : (x : â„•) â†’ A (S x)
-----------------------------------
f : (x : â„•) â†’ A x             }
f 0 = ?â‚€                      } â‰… ğŸ™
(x : â„•) â†’ f (1 + x) = ?â‚ x    }

// Note that we have a canonical isomorphism:
E : â„• â‰… ğŸ™ + â„•
//We can apply it to the domain of the Î -type of the second equation:
(x : â„•) â†’ f (1 + x) = ?â‚ x
â‰…
(x : ğŸ™ + â„•) â†’ f (1 + Eâ»Â¹ x) = ?â‚ (Eâ»Â¹ x)
â‰…
(x : ğŸ™) â†’ f (1 + Eâ»Â¹ (Left x)) = ?â‚ (Eâ»Â¹ (Left x))
â¨¯
(x : â„•) â†’ f (1 + Eâ»Â¹ (Right x)) = ?â‚ (Eâ»Â¹ (Right x))
â‰…
f (1 + Eâ»Â¹ (Left ())) = ?â‚ (Eâ»Â¹ (Left ()))
â¨¯
(x : â„•) â†’ f (1 + Eâ»Â¹ (Right x)) = ?â‚ (Eâ»Â¹ (Right x))
â‰…
f (1 + 0) = ?â‚ 0
â¨¯
(x : â„•) â†’ f (1 + (1 + x)) = ?â‚ (1 + x)
â‰…
f 1 = ?â‚ 0
â¨¯
(x : â„•) â†’ f (2 + x) = ?â‚ (1 + x)

//hence we have:

?â‚€ : A 0
?â‚ : (x : â„•) â†’ A (S x)
-----------------------------------
f : (x : â„•) â†’ A x                 }
f 0 = ?â‚€                          } â‰… ğŸ™
f 1 = ?â‚ 0                        }
(x : â„•) â†’ f (2 + x) = ?â‚ (1 + x)  }

//Apply the same iso to the type of ?â‚:
(x : â„•) â†’ A (S x)
â‰…
(x : ğŸ™ + â„•) â†’ A (S (Eâ»Â¹ x))
â‰…
(x : ğŸ™) â†’ A (S (Eâ»Â¹ (Left x)))
â¨¯
(x : â„•) â†’ A (S (Eâ»Â¹ (Right x)))
â‰…
A (S (Eâ»Â¹ (Left ())))
â¨¯
(x : â„•) â†’ A (S (Eâ»Â¹ (Right x)))
â‰…
A 1
â¨¯
(x : â„•) â†’ A (2 + x)

//Hence we have:

?â‚€ : A 0
?â‚ : A 1 â¨¯ ((x : â„•) â†’ A (2 + x))
-----------------------------------
f : (x : â„•) â†’ A x                    }
f 0 = ?â‚€                             } â‰… ğŸ™
f 1 = ?â‚.Ï€â‚                          }
(x : â„•) â†’ f (2 + x) = ?â‚.Ï€â‚‚ x        }

//Flatten the sigma:

?â‚€ : A 0
?â‚ : A 1
?â‚‚ : (x : â„•) â†’ A (2 + x)
-----------------------------------
f : (x : â„•) â†’ A x                    }
f 0 = ?â‚€                             } â‰… ğŸ™
f 1 = ?â‚                             }
(x : â„•) â†’ f (2 + x) = ?â‚‚ x           }

//QED âˆ
